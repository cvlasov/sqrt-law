\documentclass[11pt,a4paper]{report}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{multirow}

\graphicspath{{images/}}

\begin{document}

\title{Part C Project Notes}
\author{Catherine Vlasov}
\maketitle

%-----------------------
\tableofcontents


%-----------------------
\chapter{Task Documentation}

All timings mentioned here are approximate. The specific results can be found in Chapter \ref{sec:actor3-results}.

\section{Image Curation}

\subsection{Initial Image Selection}
\label{subsec:initial-image-selection}

The first step was selecting which images to use for the experiments. Flickr released a massive database of millions of images and we will use those taken by one user, referred to as \texttt{actor00003}. There are $13,349$ images taken by this user and they are on the server under \texttt{/array/vlasov/actor00003}. The largest image size in this directory is $3072\times2304$ pixels and information about all the images is in a file called \texttt{metadata.txt} in the same directory.

I wrote a script called \texttt{initial\_curation.py} to do the initial image filtering. The script uses the metadata file to identify the images that are $3072\times2304$ pixels, makes all of these images grayscale, rotates the portrait ones to landscape, and places the resulting images in a new subdirectory called \texttt{size3072}. The script took around 10 minutes to run and 9539 grayscale, $3072\times2304$ pixel, landscape images were produced.


\subsection{Choosing Image Sizes}
\label{subsec:image-sizes}

The largest size is $3072\times2304$ since that is the largest size we have from \texttt{actor00003} and the smallest size was somewhat arbitrarily chosen to be $360\times240$. In the graphs with my experiment results, I will want the image sizes (specifically the total number of pixels) to be evenly distributed along the x-axis. In order to achieve this, I picked sizes such that the difference between the number of pixels in consecutive image sizes is roughly the same. I calculated this interval using:
\begin{equation*}
\frac{3072 \cdot 2304 - 320 \cdot 240}{9} \approx 777,899 \text{ pixels}
\end{equation*}

It is straightforward to compute the total number of pixels in the $n^{th}$ image size (where $320 \times 240$ is the $1^{st}$ size and $3072 \times 2304$ is the $10^{th}$ size):
\begin{equation*}
320 \cdot 240 + (n-1) \cdot 777,899
\end{equation*}

Given the desired number of pixels (call it $P$), we can find dimensions with a 4:3 ratio that produce approximately $P$ pixels. We do so by solving the following equation for $x$ and then computing $4x$ and $3x$ to get the dimensions:
\begin{equation*}
 P \approx 4x \cdot 3x = 12x^2
 \end{equation*}

The results of these computations are:
\begin{center}
\begin{tabular}{ c  c | c}
Width & Height & Total pixels \\ \hline
3072 & 2304 & 7,077,888 \\
2912 & 2184 & 6,359,808 \\
2720 & 2040 & 5,548,800 \\
2528 & 1896 & 4,793,088 \\
2304 & 1728 & 3,981,312 \\
2048 & 1536 & 3,145,728 \\
1792 & 1344 & 2,408,448 \\
1472 & 1104 & 1,625,088 \\
1056 & 792 & 836,352 \\
320 & 240 & 76,800 \\
\end{tabular}
\end{center}


\subsection{Cropping}
\label{subsec:cropping}

I wrote a script called \texttt{crop.py} to crop the original cover photos to the sizes computed in Section \ref{subsec:image-sizes}. It takes the desired height and width as well as source and destination directories as commandline arguments. Then it computes where the cropping should start so that $8 \times 8$ blocks are cropped evenly from the top/bottom and left/right and then runs \texttt{jpegtran} to do the cropping on all the images in the given source directory. It took around 6 minutes to crop to the smallest size ($320 \times 240$) and 11 and a half minutes to crop to the second-largest size ($2720 \times 2040$).


%-----------------------
\chapter{Meeting Notes}

\section{29/04/19}

\begin{itemize}

  \item What I did:
    \begin{itemize}
      \item Pre-processed and cropped the BOSSbase images, computed their features, and their costs are in the process of being computed.
    \end{itemize}

  \item Right-justify numbers and use ``\\," to insert a space between groups of three digits that is the width of a comma

  \item I can use ``Imagemagick convert" to subtract a cover image from a stego image (command is \texttt{minus}).
  \begin{itemize}
      \item I can enhance the contrast to show more clearly which coefficients were changed.
      \item I could include an example of a stego image that the classifier successfully detected and one that the classifier did not detect and the resulting image subtractions should show how many more changes were in the one that was detected.
  \end{itemize}
  
  \item It would be cool to plot ROC curves from the classifier's results. I can extract the points on the curve from variables in the classifier code.
  \begin{itemize}
      \item Results.PFA = probability of false alarm
      \item Results.PMD = probability of misdetection
      \item ROC curve: PFA on the x-axis and 1 - PMD on the y-axis
  \end{itemize}

  \item On Tuesday we will discuss my drafts of sections 1 and 3 and prospectively discuss sections 2 and 4
  
  \item Footnotes are good for technical details (e.g. name and location of a script). I could make my GitHub repository public and include links directly to the relevant scripts.
  
  \item It is fine to write my report in the first-person rather than in the passive voice. I can use ``we" when drawing a conclusion (e.g. ``we can see that...").
  
  \item At the top of the Experimental Design chapter, I can mention that my supervisor provided me with the image sets and with the sped-up J-UNIWARD code for cost computation and say that I have highlighted them (e.g. in italics) in the places in my report where I mention/use them.

\end{itemize}

\section{Easter Break}

\begin{itemize}

  \item Complete results (from 29/03/19) with larger/smaller constants:
    \begin{center}
      \includegraphics[width=\linewidth]{graph_29_03_2019.png}
    \end{center}

\end{itemize}

\section{08/03/19}

\begin{itemize}

  \item What I did:
    \begin{itemize}
      \item Computed two new sets of constants:
      \begin{center}
        \begin{tabular}{ c | c c c }
        & $-30\%$ & Original & $+30\%$ \\ \hline
        r1 & 49176.55272727272 & 70252.21818181817 & 91327.88363636362 \\
        r2 & 27.726656205965558 & 39.609508865665084 & 51.492361525364615 \\
        r3 & 1.2845357597929208 & 1.8350510854184585 & 2.385566411043996 \\
        r4 & 0.01563280510179924 & 0.022332578716856056 & 0.029032352331912873 \\
        \end{tabular}
      \end{center}
      
      \item Computed new payload sizes for the smaller constants:
      \begin{center}
        \begin{tabular}{ c c c | c c c c }
        Width & Height & Pixels & $O(1)$ & $O(\sqrt{n})$ & $O(\sqrt{n} \cdot \log n)$ & $O(n)$ \\ \hline
        3072 & 2304 & 7077888 & 49176 & 73764 & 77762 & 110647 \\
        2912 & 2184 & 6359808 & 49176 & 69922 & 73212 & 99421 \\
        2720 & 2040 & 5548800 & 49176 & 65312 & 67790 & 86743 \\
        2528 & 1896 & 4793088 & 49176 & 60702 & 62410 & 74929 \\
        2304 & 1728 & 3981312 & 49176 & 55323 & 56194 & 62239 \\
        2048 & 1536 & 3145728 & 49176 & 49176 & 49176 & 49176 \\
        1792 & 1344 & 2408448 & 49176 & 43029 & 42261 & 37650 \\
        1472 & 1104 & 1625088 & 49176 & 35345 & 33785 & 25404 \\
        1056 & 792 & 836352 & 49176 & 25356 & 23111 & 13074 \\
        320 & 240 & 76800 & 49176 & 7683 & 5777 & 1200 \\
        \end{tabular}
      \end{center}
      
      \item Computed new payload sizes for the larger constants:
      \begin{center}
        \begin{tabular}{ c c c | c c c c }
        Width & Height & Pixels & $O(1)$ & $O(\sqrt{n})$ & $O(\sqrt{n} \cdot \log n)$ & $O(n)$ \\ \hline
        3072 & 2304 & 7077888 & 91327 & 136991 & 144416 & 205487 \\
        2912 & 2184 & 6359808 & 91327 & 129856 & 135966 & 184640 \\
        2720 & 2040 & 5548800 & 91327 & 121294 & 125895 & 161094 \\
        2528 & 1896 & 4793088 & 91327 & 112732 & 115905 & 139154 \\
        2304 & 1728 & 3981312 & 91327 & 102743 & 104361 & 115586 \\
        2048 & 1536 & 3145728 & 91327 & 91327 & 91327 & 91327 \\
        1792 & 1344 & 2408448 & 91327 & 79911 & 78485 & 69922 \\
        1472 & 1104 & 1625088 & 91327 & 65641 & 62744 & 47180 \\
        1056 & 792 & 836352 & 91327 & 47090 & 42921 & 24281 \\
        320 & 240 & 76800 & N/A & 14269 & 10728 & 2229 \\
        \end{tabular}
      \end{center}

      \item Results (so far) of experiments using smaller and larger constants:
        \begin{center}
          \includegraphics[width=\linewidth]{graph_07_03_2019.png}
        \end{center}

    \end{itemize}

  \item My next set of experiments will be on BOSSbase.

  \item I will crop the BOSSbase images to the following sizes:
  \begin{center}
  \begin{tabular}{ c c | c c }
  Width & Height & Total pixels \\ \hline
  896 & 672 & 602112 \\
  1280 & 960 & 1228800 \\
  1536 & 1152 & 1769472 \\
  1792 & 1344 & 2408448 \\
  2016 & 1512 & 3048192 \\
  2172 & 1632 & 3544704 \\
  2368 & 1776 & 4205568 \\
  2560 & 1920 & 4915200 \\
  \end{tabular}
  \end{center}

\end{itemize}


\section{01/03/19}

\begin{itemize}

  \item What I did:
    \begin{itemize}
      \item Finished all experiments and put together the results graph:
        \begin{center}
          \includegraphics[width=\linewidth]{combined_graph_27_02_2019.png}
        \end{center}
      \item Miscellaneous:
        \begin{itemize}
          \item I parallelised the feature computation just like with embedding by looking at the last digit of the image numbers to spin up ten concurrent processes. Before, the feature files were being computed sequentially, which took 5-10 hours (depending on the image size). Now it takes less than 30 minutes.
          \item I tried using \texttt{at} for task scheduling, but realised that it means that I lose the timing information. This is because \texttt{at} either swallows the standard output/error or emails it to you, given the appropriate command line argument. But, there doesn't seem to be an appropriate email program installed and I don't know if it's worth it to use.
          \item A lot of timing information for the binary embedding was lost because somehow I (or my script) didn't specify/incorrectly specified a file for redirecting the standard output when running commands with \texttt{nohup}. It was all instead written to the default \texttt{nohup.out} file, which is now a big mess because many processes were writing to it concurrently. I made a note of all the tasks for which I have not timing information in my results tables at the end of this document.
          \item I made a copy of all the features into \texttt{/home} as a backup.
          \item I didn't end up applying to the BCS conference because of personal matters I had to deal with last week (deadline was Friday 22nd February) and because of uncertainty with what I was going to do over the break.
          \item I just booked my flights back to Canada and I am gone from 12th March to 4th April.
          \item I started adding papers to my bibliography. What format do I use? Which pieces of information are necessary (e.g. location, specific date as opposed to year)?
        \end{itemize}
      \item Next: do the same set of experiments but with two different constants - which ones?
    \end{itemize}

\item Now redo the experiment with two new sets of constants. These can be +/- 30\% of the existing ones. Should result in graphs with very similar shapes, just shifted slightly upwards and downwards, respectively.

\item I should also try training the classifier on all image sizes (e.g. a tenth of the images of each size) and then finding its error rate on images of each size.

\item It would be good to run these experiments on another images set. Dr. Ker will dig up the BOSSBase images and I can use these next.

\end{itemize}

\section{15/02/19}

\begin{itemize}

  \item What I did:
    \begin{itemize}
      \item Reran \texttt{calculate\_payload\_sizes.py} to get the right $O(\sqrt{n}\cdot\log{n})$ payload sizes (now $2048\times1536$ has the same payload size in all cases):
      \begin{center}
        \begin{tabular}{ c c c | c c c c }
        Width & Height & Pixels & $O(1)$ & $O(\sqrt{n})$ & $O(\sqrt{n} \cdot \log n)$ & $O(n)$ \\ \hline
        3072 & 2304 & 7077888 & 70252 & 105378 & 111089 & 158067 \\
        2912 & 2184 & 6359808 & 70252 & 99889 & 104589 & 142030 \\
        2720 & 2040 & 5548800 & 70252 & 93303 & 96843 & 123919 \\
        2528 & 1896 & 4793088 & 70252 & 86717 & 89158 & 107042 \\
        2304 & 1728 & 3981312 & 70252 & 79033 & 80278 & 88912 \\
        2048 & 1536 & 3145728 & 70252 & 70252 & 70252 & 70252 \\
        1792 & 1344 & 2408448 & 70252 & 61470 & 60373 & 53786 \\
        1472 & 1104 & 1625088 & 70252 & 50493 & 48264 & 36292 \\
        1056 & 792 & 836352 & 70252 & 36223 & 33016 & 18677 \\
        320 & 240 & 76800 & 70252 & 10976 & 8253 & 1715 \\
        \end{tabular}
      \end{center}
    \end{itemize}

\end{itemize}

\section{08/02/19}

\begin{itemize}

  \item What I did:
    \begin{itemize}
      \item Fixed problems with the binary embedding code.
        \begin{itemize}
          \item There was a problem with the exponential search for lambda getting stuck in an infinite loop. Then, I figured out that the floating point precision in the binary search for $\lambda$ was insufficient for finding a value of $\lambda$ such that the entropy sum is in the range $b \leq \lambda < b+1$, where $b$ is the number of payload bits. For $b = 70252$, it turned out that the entropy sum reached $70,253$ but could no longer be refined because the upper and lower bounds for $\lambda$ had reached the limits of the floating point precision.
        \end{itemize}
      \item Ran binary embedding on all image sizes for the $O(\sqrt{n})$ payloads (and all payload sizes for the $320\times240$ images)
        \begin{itemize}
          \item There were hangups in the middle of the embedding processes, so I killed all processes.
        \end{itemize}
      \item Noticed that the payload sizes computed for $O(\sqrt{n}\cdot\log{n})$ are wrong because the number of bits for the middle size is different from the the number of bits for the same size but other proportions. Probably a bug in the code.
    \end{itemize}

  \item The MinPE values for the processes that finished (only the ones for $320\times240$ images) look correct.
  
  \item There was indeed a bug in my \texttt{calculate\_payload\_sizes.py} script - I forgot to replace one of the calls to \texttt{log(x)} with \texttt{log(x,2)}, to use the right logarithm base.

\end{itemize}

\section{25/01/19}

\begin{itemize}

  \item What I did:
    \begin{itemize}
      \item Finished the graph template for the experiment results:
        \begin{center}
          \includegraphics[width=0.7\linewidth]{graph_template.png}
        \end{center}
        \begin{itemize}
          \item If we decide to use only one proportionality constant for each payload size, then we will only have one plot per figure (rather than three like in the 2008 paper).
        \end{itemize}
    
      \item Finished writing the binary embedding code.
        \begin{itemize}
          \item Not quite working. Either throws an unknown error or behaves as if there are no images to process.
        \end{itemize}
    \end{itemize}

\end{itemize}

\section{11/01/19}

\begin{itemize}

  \item What I did:
    \begin{itemize}
      \item Finished running J-UNIWARD on all remaining images sizes.
      \item Picked values for $r_1, r_2, r_3, r_4$.
        \begin{itemize}
          \item The image size and $\alpha$ combination that produced a MinPE value closest to 20\% was $1056\times792$ with $\alpha=0.3$ (MinPE = 22\%).
          \item I ran \texttt{JPEG-UTILS} on all the $1056\times792$ images and found that the average number of non-zero coefficients was $120,746$.
          \item Since 0.3 bits per non-zero coefficient were embedded in each image, this means that an average of $0.3 \times 120,746 = 36,224$ bits were embedded per image.
          \item I chose $2048 \times 1536$ to be the "middle" image size. There are ten sizes, so it was either this or $2304 \times 1728$.
          \item I wrote a script \texttt{calculate\_payload\_sizes.py} that computes the number of bits that should be embedded for each image size for each proportion (i.e. $O(1)$, $O(\sqrt{n})$, $O(\sqrt{n} \cdot \log n)$, and $O(n)$, where $n$ is the number of pixels in each image).
          \item Compute the constant values computed as intermediate values by my script are:
            \begin{itemize}
              \item $r_1 = 70252.21818181817$
              \item $r_2 = 39.609508865665084$
              \item $r_3 = 2.64741910071112$
              \item $r_4 = 0.022332578716856056$
              \item For some reason, these values (and the values in the table below) differ when run on my computer versus on the server.
            \end{itemize}
          \item Using these constants, compute the number of bits to embed for each image size:
          \begin{center}
            \begin{tabular}{ c c c | c c c c }
            Width & Height & Pixels & $O(1)$ & $O(\sqrt{n})$ & $O(\sqrt{n} \cdot \log n)$ & $O(n)$ \\ \hline
            3072 & 2304 & 7077888 & 70252 & 105378 & 160268 & 158067 \\
            2912 & 2184 & 6359808 & 70252 & 99889 & 150891 & 142030 \\
            2720 & 2040 & 5548800 & 70252 & 93303 & 139714 & 123919 \\
            2528 & 1896 & 4793088 & 70252 & 86717 & 128628 & 107042 \\
            2304 & 1728 & 3981312 & 70252 & 79033 & 115816 & 88912 \\
            2048 & 1536 & 3145728 & 70252 & 70252 & 101352 & 70252 \\
            1792 & 1344 & 2408448 & 70252 & 61470 & 87100 & 53786 \\
            1472 & 1104 & 1625088 & 70252 & 50493 & 69631 & 36292 \\
            1056 & 792 & 836352 & 70252 & 36223 & 47632 & 18677 \\
            320 & 240 & 76800 & 70252 & 10976 & 11906 & 1715 \\
            \end{tabular}
          \end{center}
        \end{itemize}
    \end{itemize}

\item Later we can try training the classifier on all image sizes (maybe 10\% of the images of each size) and then run it against the images of each size. It can also be run against a set of images of multiple sizes.

\item Once we have the results, we can also try running all the experiments again on another set of images (from another actor).
  \begin{itemize}
    \item Actor 27 has 4890 images shot on an iPhone, but they are very small ($320 \times 480$).
    \item Actor 245 has 1524 images shot on an iPhone, of various different sizes.
    \item Actor 17 has a Sony camera with a good number of images and a nice camera.
    \item We could also use the original BossBase images (as opposed to the ones that have been shrunken down to $512 \times 512$). But a bit overused and artificial since they come from lots of different cameras.
  \end{itemize}

\item YFCC100m dataset

\end{itemize}

\section{03/12/18}

\begin{itemize}

\item What I did:
  \begin{itemize}
  \item Found a way to convert the features in the \texttt{imageXXXXX.fea} files into a format that the linear classifier can use.
    \begin{itemize}
    \item Wrote \texttt{combine\_feature\_files.py}, which creates a single file (e.g. \texttt{sizeX\_cover.fea}) with the features of all the images in a directory, one image per line. Each line is tab-separated and has the image name followed by the features (in row order).
    \item Wrote \texttt{txt\_to\_mat.m}, which takes a combined feature file and produces a \texttt{.mat} file that MATLAB can read to get the features in fields with names (and dimensions) that it expects.
    \end{itemize}

  \item Ran (ternary) J-UNIWARD embedding with $\alpha = 0.1$ on the six smallest image sizes.
    \begin{itemize}
    \item Realized that I wasn't reusing the J-UNIWARD costs I had previously computed, so I killed the processes that hadn't terminated yet (sizes  $1792 \times 1344, 2048 \times 1536, 2304 \times 1728$)
    \end{itemize}

  \item Created a modified J-UNIWARD that reads in the pre-computed costs from the \texttt{imageX.costs} files in the cover image directory.
    \begin{itemize}
    \item Started running this on the sizes that hadn't terminated without reusing costs.
    \item Sizes $1792 \times 1344, 2048 \times 1536, 2304 \times 1728$ haven't terminated yet although they've been running for several days.
    \end{itemize}

  \item Ran \texttt{compute\_features.py} on $J_{0.1}$ images (sizes $320 \times 240, 1056 \times 792, 1472 \times 1104$).
  
  \item Started working on modifying J-UNIWARD to do binary embedding.
  \end{itemize}

\end{itemize}


\section{21/11/18}

\begin{itemize}

\item What I did:
  \begin{itemize}
  \item Wrote \texttt{feature\_sanity\_check.py}, which adds up all the features for each image in a directory and outputs how many had the same sum (1346, a constant) and how many had zero sum (due to no features being generated).
    \begin{itemize}
    \item Ran it on all image sizes and found that the number of images for which the features weren't generated when I ran JRM on 10/11/18 increased as the image sizes increased.
    \end{itemize}

  \item Reran \texttt{compute\_features.py} on all images of all sizes.
     \begin{itemize}
     \item This time no images were skipped, which is good. However, the timing information was lost because for some reason the terminal output was not redirected to a file by \texttt{nohup}. This may have been caused by the fact that \texttt{nohup} was run by a Bash script for each file size and most likely I forgot the \texttt{\&} at the end of the line. All I know is that all processes finished after around 18-20 hours. This roughly matches the timing information from the original run on 10/11/18 when some images were skipped.
     \item I reran \texttt{feature\_sanity\_check.py} for all sizes. This confirmed that no images were skipped and that the sum of all features in each image of each size was 1346, as expected.
     \end{itemize}

  \item Changed \texttt{compute\_costs.py} so that Python's \texttt{multiprocessing} module is used for multithreading in order to spread out the cost computation over multiple processes to speed it up.
    \begin{itemize}
    \item I initially tried using Python's \texttt{threading} module, however creating multiple threads does not actually mean the computation is run in parallel due to Python's \href{https://docs.python.org/2/glossary.html\#term-global-interpreter-lock}{global interpreter lock (GIL)}.
    \item \texttt{multiprocessing}, on the other hand, avoids the limitations of the GIL and allows multiple processes (as opposed to threads) to be created and make use of multiple cores.
    \item \href{https://stackoverflow.com/a/3046201}{Here} is a good pro/con analysis of the two modules.
    \end{itemize}

  \item Ran \texttt{compute\_costs.py} on all images of all sizes.
    \begin{itemize}
    \item All cost files were generated, as expected.
    \item The terminal output is messy due to multiple processes printing concurrently. However, the total time is clearly visible on the last line of the terminal output.
    \end{itemize}

  \item TL;DR the costs and features of all cover images are all computed!
  
  \item Wrote my own program called \texttt{JPEG-UTILS}, which is based on the J-UNIWARD code and provides a number of checks and information about cover/stego images.
    \begin{itemize}
    \item Currently it provides two utilities:
      \begin{enumerate}
      \item Non-zero coefficient count: number of non-zero coefficients in a (cover) image
      \item Differing coefficients: number of coefficients that differ between cover/stego image pairs, broken down by the number that differ by +1, -1, or something else.      
      \end{enumerate}
    \end{itemize}

  \item Looked into how to implement my own binary embedding and it looks like there's no need to reinvent the wheel and the J-UNIWARD code can mostly be reused. Want to discuss.
  \end{itemize}

\item \textit{Should I rerun the feature computations just to get the timing information? It takes 18-20 hours.}
  \begin{itemize}
  \item I can, but it's not a priority now. I could do it later when I'm running the real experiments.
  \end{itemize}

\item The \texttt{float* pixel\_costs} in \texttt{cost\_model.cpp} of the J-UNIWARD code looks like it's initialized, filled, and then never used, but its ``initialization'' is actually C pointer arithmetic based on the address of the \texttt{float* costs} which is a field inherited from \texttt{base\_cost\_model.cpp}.

\item Equations for binary versus ternary embedding
  \begin{enumerate}
  \item Binary embedding
    \begin{itemize}
    \item This is the probability of changing coefficient $i$ by $\pm1$, where $c_i$ is the cost of changing coefficient $i$ (by $\pm1$) and $c_{\neg i} = 0$ is the cost of not changing it:
      \begin{equation*}
      \pi_i = \frac{1}{1+e^{\lambda c_i}} = \frac{1}{e^{\lambda c_{\neg i}}+e^{\lambda c_i}} = \frac{e^{-\lambda c_i}}{e^{-\lambda c_{\neg i}}+e^{-\lambda c_i}}
      \end{equation*}
    \item Entropy function for coefficient $i$:
      \begin{equation*}
      - \pi_i \log \pi_i - (1 - \pi_i) \log (1 - \pi_i)
      \end{equation*}
    \end{itemize}

  \item Ternary embedding
    \begin{itemize}
    \item This is the probability of changing coefficient $i$ by $+1$ (for example), where $c^0_i = 0$ is the cost of not changing coefficient $i$, $c^{+1}_i$ is the cost of changing it by $+1$, and $c^{-1}_i$ is the cost of changing it by $-1$:
    \begin{equation*}
    \pi^{+1}_i = \frac{e^{-\lambda c^{+1}_i}}{1+e^{-\lambda c^{+1}_i}+e^{-\lambda c^{-1}_i}} = \frac{e^{-\lambda c^{+1}_i}}{e^{-\lambda c^0_i}+e^{-\lambda c^{+1}_i}+e^{-\lambda c^{-1}_i}}
    \end{equation*}
      \begin{itemize}
      \item In practice, $c^{+1}_i = c^{-1}_i (= C \text{, say})$ for all $i$, meaning that the costs of adding one versus substracting one are the same, so:
      \begin{equation*}
      \pi^{+1}_i =\pi^{-1}_i =  \frac{e^{-\lambda C}}{1+2 \cdot e^{-\lambda C}}
      \end{equation*}
      \end{itemize}
    \item Entropy function for coefficient $i$:
      \begin{equation*}
      - \pi^{+1}_i \log \pi^{+1}_i - \pi^{-1}_i \log \pi^{-1}_i - \pi^0_i \log \pi^0_i
      \end{equation*}
    \end{itemize}
  \end{enumerate}

\item \textit{Can I reuse the structure of the J-UNIWARD code to implement binary embedding?}
  \begin{itemize}
  \item Yes, but I need to be careful to make sure things are read in the right order and all methods whose implementations are specifically for ternary embedding are adapted to be for binary embedding.
  \item Specifically, the entropy function and probability computation need to be changed to use the equations described in the point above.
  \item I also need to adapt it so that it takes a number of bits as an argument instead of the number of bits per non-zero coefficient.
  \end{itemize}

\item The \href{http://dde.binghamton.edu/kodovsky/pdf/SPIE2012_Kodovsky_Steganalysis_of_JPEG_Images_Using_Rich_Models_paper.pdf}{JRM paper} describes how JRM produces 22,510 features. These are actually made up of two sets of 11,255 features, one for the image itself and one for the same image, but with 4-pixel strips cropped off all sides (``Cartesian calibration'').
  \begin{itemize}
  \item The reason the features all add up to the same constant for each image, regardless of size, is that the features are normalized so that they sum to 1. The way JRM computes the features is based on ``submodels'' and all images have the same number of submodels (672) regardless of size.
  \item The features within each submodel (something like this) are normalized, so summing all the features of both halves (from the two versions of the image), makes a total sum of $672\cdot1 + 672\cdot1 = 1346$, which is what we get when running \texttt{feature\_sanity\_check.py}.
  \end{itemize}

\item When I run J-UNIWARD for the pre-experiments, I should actually use 0.1 instead of 0.4 as previously discussed.
  \begin{itemize}
  \item For BOSSbase, where all images are $512 \times 512$, $\alpha = 0.2$ produced a ``good'' classification error rate. However, those images are about $\frac{1}{4}$ of a megapixel whereas the middle size images in our dataset are about $3$ megapixels.
  \end{itemize}

\item Step-by-step explanation of how we'll choose constants $r_1, ... , r_4$ in order to compute the number of bits of payload to embed. \underline{Goal}: pick them such that $r_1 = r_2 \cdot \sqrt{n_{mid}} = r_3 \cdot \sqrt{n_{mid}} \cdot \log n_{mid} = r_4 \cdot n_{mid}$, where $n_{mid}$ is the number of pixels in the ``middle'' image size.
  \begin{enumerate}
  \item Run J-UNIWARD with $\alpha = 0.1$ on some of the image sizes (among the smaller half of the sizes).
  \item Compute the features of these stego images and then train and run the classifier on these cover-stego image pairs.
  \item Record the classifier's error rate (call it $P_e$) for each image size.
  \item We want to find an image size where $P_e \approx 20\%$. Using \texttt{JPEG-UTILS}, see how many non-zero coefficients there were on average and then use this and $\alpha = 0.1$ to compute the average number of bits that were embedded (well, simulated).
  \item Assuming the square root law holds, pro-rate this to compute the number of bits that should be embedded in the middle image size. Call this $m^{\ast}_{mid}$.
  \item Knowing $m^{\ast}_{mid}$ and $n_{mid}$, compute $r_1, ... , r_4$ so that:
    \begin{align*}
    m^{\ast}_{mid} &= r_1 \\
    m^{\ast}_{mid} &= r_2 \cdot \sqrt{n_{mid}} \\
    m^{\ast}_{mid} &= r_3 \cdot \sqrt{n_{mid}} \cdot \log n_{mid} \\
    m^{\ast}_{mid} &= r_4 \cdot n_{mid}
    \end{align*}
  \end{enumerate}

\item 95\% confidence interval formula (where $P$ is the error rate and $n$ is the sample size):
  \begin{equation*}
  \pm 1.96 \cdot \sqrt{\frac{P \cdot (1-P)}{n}}
  \end{equation*}

\item We don't need to worry about splitting the data into training, validation, and testing sets. We can let the classifier handle it using its default behaviour. We're not too concerned about doing ``perfect'' machine learning since we can't get many significant figures in our rates in a statistically significant way given that we only have 10,000 images.

\end{itemize}


\section{14/11/18}

\begin{itemize}

\item What I did:
  \begin{itemize}
  \item Ran the hacked J-UNIWARD to compute the costs of all the images of all sizes.
    \begin{itemize}
    \item It computed the costs of all the $320 \times 240$ images after about 2 hours, but the processes computing the costs for the other sizes either terminated in the middle of their execution (before finishing all images), or did not terminate at all (in the case of $2912 \times 2184$ and $2720 \times 2040$) althought they were not making any progress.
    \end{itemize}

  \item Wrote \texttt{compute\_features.py}, which runs JRM on all the JPEGs in a directory and saves the results to a \texttt{.fea} file.
  
  \item Ran \texttt{compute\_features.py} on all images of all sizes.
    \begin{itemize}
    \item All ten processes terminated and processed all images.
    \item The slowest one took 1h22m and the longest one took 20h4m.
    \item However, some of the \texttt{.fea} files generated were empty and I don't know why.
    \end{itemize}

  \item Was sick the last week, so didn't get much else done.
  \end{itemize}

\item The timing of me running J-UNIWARD and JRM (in parallel) coincided with some issues on the server with regard to memory.
  \begin{itemize}
  \item It ended up being restarted, so I should just rerun everything.
  \item Apparently, JRM does sometimes silently fail. However, when I reran it on some of the images whose features were not computed, it worked which was odd.
  \end{itemize}

\item It's possible that there was an issue with the simultaneous cost and feature computations because the \texttt{compute\_features.py} iterated through all files in the directory while more files were being generated both by itself and by J-UNIWARD.
  \begin{itemize}
  \item When rerunning the computations, I'll modify my script to iterate from 1 to 13349 to ``create'' the image names itself (and check that they actually exist, since not all 13349 images were used), which will avoid any issues with simultaneous directory iteration and file generation.
  \end{itemize}

\item The sums of the features of each image should be a constant, so it would be a good idea to do a sanity check to ensure that this is indeed the case.

\item To make the cost and feature computations go faster, it would be a good idea to spin off multiple threads (in Python).
  \begin{itemize}
  \item For instance, I could spin off 10 threads and make thread 1 handle images with number 1 (mod 10).
  \end{itemize}

\item Before running experiments, we need to choose constants $r_1, ... , r_4$ in order to compute the number of bits of payload to embed.
  \begin{itemize}
  \item Amounts: $r_1, r_2 \cdot \sqrt{n}, r_3 \cdot \sqrt{n} \cdot \log n, r_4 \cdot n$ for each \# of pixels $n$.
  \item To choose $r_1, ... , r_4$, we do the following:
    \begin{enumerate}
    \item Run J-UNIWARD with 0.4 bits per non-zero coefficient for all (or every other) image size.
    \item Write and run a script that counts the number of coefficients that differ between the cover and stego images.
    \item From those counts, compute the number of bits that were embedded for each size.
    \item Compute the features of the stego images.
    \item Train the classifier with the features of the cover and stego images.
    \item Run the classifier to determine detectability for each image size.
    \item ...? CLARIFY
    \end{enumerate}
  \item We'll choose $r_1, ... , r_4$ such that the ``middle'' image size is in the ``middle'' among image sizes in terms of detectability. CLARIFY
  \item Something about number of non-zero coefficients...
  \end{itemize}

\end{itemize}


\section{07/11/18}

\begin{itemize}

\item What I did:
  \begin{itemize}
  \item Created the file structure on the server.
    \begin{itemize}
    \item Each \texttt{actor00003/sizeXXXX/} directory has one subdirectory called \texttt{cover}.
    \item We need to decide/calculate how many bits of payload to embed for each size before creating subdirectories for all the different payload sizes.
    \end{itemize}

  \item Changed \texttt{initial\_curation.py} so that constants in the file are instead passed in as command-line arguments.
    \begin{itemize}
    \item Reran it and it was almost twice as fast (11 vs 19 minutes), though the speedup is probably not related to this change.
    \end{itemize}

  \item Finished \texttt{compute\_probabilities.py}. It finds a $\lambda$ such that:
    \begin{equation*}
    \sum\limits_{i=1}^N H_2(\pi_i) \in [m, m+1)\text{, where $m$ is the payload size to simulate}
    \end{equation*}

  \item Wrote \texttt{crop.py} and ran it for the other nine image sizes.
    \begin{itemize}
    \item It crops $8\times8$ blocks evenly from the top/bottom and right/left.
    \item The process is documented in Section \ref{subsec:cropping}.
    \end{itemize}

  \item Refactored the J-UNIWARD code (C++ source files) for readability and uploaded them to my GitHub repository in the \texttt{j-uniward} directory.
    \begin{itemize}
    \item Created a version that integrates Dr. Ker's hack to save the costs to a file (in ASCII) without doing the actual embedding.
    \item 99\% sure the costs are output in row order, which would be the intuitive way to implement it.
  \end{itemize}

  \item Started working on \texttt{compute\_costs.py}, which runs the hacked J-UNIWARD on all images in a directory.
  \end{itemize}

\item Computing the costs for all the images of all sizes
  \begin{itemize}
  \item On one core, it will take:
    \begin{equation*}
    50s \times 10000 \times (1 + 0.9 + ... + 0.1) \approx 763 \text{ hours} \approx 32 \text{ days}
    \end{equation*}
  \item I can use 8-10 of the server's 40 cores.
  \item I'll run the script using \texttt{nohup} once per directory and obviously the process will finish faster for the smaller images, so I can start on the next task (feature computation) with those that finish first.
  \end{itemize}

\item Once the costs are computed, the next task is computing the features using JRM.

\item Then, I'll start by using J-UNIWARD with 0.4 bits per non-zero coefficient. I then need to compute the features of the stego objects. Once this is done, I can train the classifier with the features of all the cover and stego objects.
  \begin{itemize}
  \item The original plan was to use the \href{http://dde.binghamton.edu/download/ensemble/}{ensemble classifier}.
  \item We will instead use a \href{http://dde.binghamton.edu/download/LCLSMR/}{low-complexity linear classifier}, which achieves similar performance but has a lower computational complexity.
  \end{itemize}

\item When training the classifier, it's important to keep the cover/stego objects pairs together (i.e. not put the cover in the training set and the stego in the testing test for cross-validation).
  \begin{itemize}
  \item This is important because it ensures the classfier learns the correct boundary.
  \end{itemize}

\item The binary embedding I'll write will take the number of bits to embed as input.
  \begin{itemize}
  \item We will compute the specific number of bits to run the embedding with by manually computing $r \cdot \sqrt{n}$ and $r \cdot \sqrt{n} \cdot \log n$, where $n$ is the total number of pixels in each image and $r$ is some constant we'll pick.
  \item We'll pick $r$ such that it makes the detectability of the ``middle'' image size the median among the detectabilities of all the sizes, where ``detectability'' refers to the classifier's accuracy.
  \end{itemize}

\item When the classifier training function asks for the costs ``row-by-row'', they mean it should be a big matrix where the first half of the rows are the costs of the cover images, in order, and the second half are the costs of the stego images, in the same order.

\end{itemize}


\section{31/10/18}

\begin{itemize}

\item What I did:
  \begin{itemize}
  \item Put together this document
  \item Organized all documents and scripts in my (private) GitHub repository
  \item Fixed \texttt{initial\_curation.py} (the problem is documented in Section \ref{sec:lessons-learned}) and I successfully ran it on the server
    \begin{itemize}
    \item Original images: \texttt{/array/vlasov/actor00003/original}
    \item All $3072\times2304$, grayscale, landscape images are in a new directory \texttt{/array/vlasov/actor00003/size3072}
    \end{itemize}
  \item Learned how to use \texttt{pyplot}, plotted $H_2$ as an exercise
  \item Computed the image sizes we'll use (the process and results are described in Section \ref{subsec:image-sizes})
    \begin{itemize}
    \item The method discussed on 24/10/18 doesn't work. It does produce equally sized intervals (in terms of the difference in the total number of pixels between consecutive sizes), but only between $320\times240$ and the ninth-largest size since this interval is only around $70,000$. The ninth-largest size would be $960\times720$, which is clearly much smaller than $3072\times2304$.
    \item In order to get sizes linearly distributed in terms of the total number of pixels, the interval needs to be closer to $700,000$ pixels.
    \end{itemize}
  \item Started working on \texttt{compute\_probabilities.py}
  \end{itemize}

\item \textit{Is the value of $\lambda$ bounded? How should the binary search (in the context of PLS) work?}
  \begin{itemize}
  \item $\lambda = 0$ corresponds to maximum entropy (aka. maximum payload) because then $\pi_i = \frac{1}{1+e^{\lambda c_i}} = \frac{1}{2}$

  \item As $\lambda \rightarrow \infty$, $\pi_i \rightarrow 0$

  \item The order of magnitude of $\lambda$ depends on the order of magnitude of the costs.

  \item The binary search will have two stages:
    \begin{enumerate}
    \item Exponential search to find an upper bound on $\lambda$. This will involve trying exponentially large values such as $0, 1, 10, 100, ...$ until a value is found such that $\sum\limits_{i=1}^N H_2(\pi_i) < M$
    \item Suppose the first value where this inequality holds is $\lambda = 10^n$. We now do a binary search for $\lambda$ with a lower bound of $10^{n-1}$ and an upper bound of $10^n$ and we want to find a value such that $\sum\limits_{i=1}^N H_2(\pi_i) \in [m, m+1)$, where $m$ is the number of payload bits.
    \end{enumerate}
  \end{itemize}
  
\item In Dr. Ker's paper ``On the Relationship Between Embedding Costs and Steganographic Capacity'' from June 2018, he writes about how if the detector knows the costs $c_1, c_2, ... c_N$, then the objective that should be minimized is $\sum\limits_{i=1}^N c_i \pi_i^2$, which is the same as the objective in PLS except with the $\pi_i$ terms squared.
  \begin{itemize}
  \item This is a possible project extension.

  \item The tricky part is computing the probabilities since the optimal solution is no longer $\pi_i = \frac{1}{1+e^{\lambda c_i}}$. Instead, it's $\frac{\pi_i}{H_{2}'(\pi_i)} = \lambda c_i$.

  \item The probabilities can be computed by running Newton-Raphson several times (Dr. Ker did it 8 times)

  \item I don't need to tackle this now, but it's worth keeping in mind.
  \end{itemize}

\item When I use Dr. Ker's J-UNIWARD hack, I need to make sure that I work out the order in which the costs are written to the file.
  \begin{itemize}
  \item It's hard to tell just by looking at the costs whether or not they're in the right order. If I'm wrong, I'll probably find out since the embedding will be very detectable.
  \item It's very likely that the $8\times8$ blocks are analyzed from left to right, top to bottom. However, within each block the costs could be left to right, top to bottom \textbf{or} in the zigzag order used to store the quantized coefficients. I need to check this.
  \end{itemize}

\item Once I compute the probabilities, it might be a good idea to use Python's \texttt{random.seed(..)} method (with the image number as the seed) in order to do the embedding. It can be used to determine whether or not to change each coefficient and so I'll always get the same embedding with the same cover, modulo rounding.

\item Dr. Ker has a faster version of JRM for feature extraction.

\item Tips:
  \begin{itemize}
  \item After embedding, open the stego image to make sure nothing got messed up (e.g. due to the order of the costs or coefficients).

  \item It would be a good idea to write some scripts to check things like:
    \begin{itemize}
    \item The number of coefficients that differ between the cover and stego images is $\approx \sum\limits_{i=1}^N \pi_i$
    \item Coefficients that differ between the cover and stego images only differ by $\pm1$
    \end{itemize}

  \item Test things out on small images (e.g. $64\times64$) to save time in case there are bugs.
  \end{itemize}

\end{itemize}


\section{24/10/18}

\begin{itemize}

\item What I did:
  \begin{itemize}
  \item Read Chapter 3 of the Advanced Security notes on steganography
  \item Wrote a script (\texttt{initial\_curation.py}) to find all the largest images in the \texttt{actor00003} directory and then make them all grayscale and landscape (described in Section \ref{subsec:initial-image-selection})
    \begin{itemize}
    \item Wasn't quite working due to ``\texttt{Empty input file}'' error when performing multiple \texttt{jpegtran} operations
    \end{itemize}
  \end{itemize}

\item Action plan:
  \begin{enumerate}

  \item Calculate image sizes
    \begin{itemize}
    \item Preserve the 4:3 aspect ratio, not because we have to but because we can and it means we can keep things as similar as possible

    \item The largest image size we'll use is $3072\times2304$ since that's the size of the largest \texttt{actor00003} images.

    \item The smallest size will be $320\times240$ since that's a relatively common image size (and it has a 4:3 aspect ratio)

    \item The short-edge dimensions will be computed by hand by calculating $240x$ (where $x=\sqrt{1}, \sqrt{2},...,\sqrt{10}$) and then rounding to the nearest multiple of 24. Then the long-edge dimensions are calculated such that the 4:3 ratio is maintained.
    \end{itemize}

  \item Create the directory structure on the server in \texttt{/array/vlasov/}
    \begin{itemize}
    \item Keep a copy of all the original images in \texttt{actor00003/original}

    \item Create one directory per image size, called \texttt{size3072} (for instance)

    \item For each size, create two subdirectories:
      \begin{enumerate}
      \item One for the unaltered images, called \texttt{cover}
      \item One per number of payload bits, called \texttt{stego-1234bits}
      \end{enumerate}

    \item Each \texttt{cover} subdirectory will have three files per cover image:
      \begin{enumerate}
      \item \texttt{image12345.jpg}: the unaltered image
      \item \texttt{image12345.costs}: the costs computed by J-UNIWARD
      \item \texttt{image12345.fea}: the features computed by JRM
      \end{enumerate}

    \item Each \texttt{stego-1234bits} subdirectory will have one file per stego image:
      \begin{enumerate}
      \item \texttt{image12345.jpg}: the stego image, which is the cover image \texttt{sizeXXXX/cover/image12345.jpg} with a 1234-bit message embedded in it
      \end{enumerate}
    \end{itemize}

  \item Crop the $3072\times2304$ cover images to the sizes calculated in task 1. Do this by cropping $8\times8$ pixel blocks evenly from the top/bottom and right/left.

  \item Generate the costs (using Dr. Ker's slighty modified J-UNIWARD code) and features (using JRM) for all the cover images of all the different sizes.
  \begin{itemize}
  \item JRM produces 22510 real numbers (the features)
  \item Up to me how to store them, but ASCII is probably the most portable
  \end{itemize}

  \item Use J-UNIWARD to embed 0.4 bits per non-zero AC coefficient in some of the covers.

  \item Write a function that takes the number of payload bits as input and computes the probabilities with which each coefficient changes during (binary) embedding.
    \begin{itemize}
    \item Goal: given the costs $c_1, c_2, ... c_N$ (where N is the total number of coefficients) of changing each coefficient (by adding or subtracting one), compute the probabilities $\pi_1, \pi_2, ..., \pi_N$ of making each of these changes

    \item Size of the payload: $\sum\limits_{i=1}^N H_2(\pi_i)$
      \begin{itemize}
      \item $H_2$ is the ``entropy'' and is defined as:
        \begin{equation*}
        H_2(x) = -x \cdot \log_2 x - (1-x) \cdot \log_2 (1-x)
        \end{equation*}

      \item Graph of $H_2$:
        \begin{center}
          \includegraphics[width=0.7\linewidth]{h2_plot.png}
        \end{center}
      \end{itemize}

    \item Average total cost: $\sum\limits_{i=1}^N c_i \pi_i$

    \item Two (equivalent) optimization problems for computing the payload size:
      \begin{enumerate}
      \item Distortion-limited sender (DLS)
        \begin{equation*}
        \text{Maximize } \sum\limits_{i=1}^N H_2(\pi_i) \text{ such that } \sum\limits_{i=1}^N c_i \pi_i \leq C
        \end{equation*}

      \item Payload-limited sender (PLS)
        \begin{equation*}
        \text{Minimize } \sum\limits_{i=1}^N c_i \pi_i \text{ such that } \sum\limits_{i=1}^N H_2(\pi_i) \geq M
        \end{equation*}
      \end{enumerate}

    \item For some fixed $\lambda$, we can compute the probabilities:
      \begin{equation*}
      \pi_i = \frac{1}{1+e^{\lambda c_i}}
      \end{equation*}

    \item We'll use PLS, where M is the payload size.
      \begin{itemize}
      \item The optimal solution is when $\sum\limits_{i=1}^N H_2(\pi_i) = M$
      \item $\sum\limits_{i=1}^N H_2(\pi_i)$ is actually monotonically decreasing, so we can find a value of $\lambda$ such that $\sum\limits_{i=1}^N H_2(\pi_i) = M$ for any M we choose. Then, we can compute the probabilities $\pi_1, \pi_2, ..., \pi_N$ using this value of $\lambda$.
      \item The end goal is to do the embedding ourselves by modifying each coefficient with these probabilities.
      \end{itemize}
    \end{itemize}

  \end{enumerate}

\item \textit{Is 80 a standard JPEG quality factor (QF)?} In the massive image database released by Flickr, the most common QFs were 100, the QF used by iPhones, and 80. So, we're using 80 because that gives us a greater selection of images.

\end{itemize}


\section{17/10/18}

\begin{itemize}

\item What I did:
  \begin{itemize}
  \item Read Chapters 1 and 2 of the Advanced Security notes on steganography
  \item Read the 2008 paper ``The Square Root Law of Steganographic Capacity''
  \end{itemize}

\item Discussed questions I had about Chapter 1 (Steganography) and Chapter 2 (Steganalysis) of the Advanced Security notes and about the 2008 paper.
  \begin{itemize}

  \item \textit{What is downsampling?} Shrinking

  \item \textit{When you take a pictures on your phone, what happens?} Captures raw image, immediately compresses it as a JPEG, and discards the raw image

  \item \textit{What determines a cover's ``source''?} Primarily the camera. The camera's ISO setting, in particular, is very important. The subject of the photos don't make much of a difference.

  \item \textit{In JPEG compression, don't you lose some information when dividing the image into $8\times8$ pixel blocks?} No, the DCT is linear (i.e. 1-to-1 mapping from $8\times8$ blocks to coefficients)

  \item \textit{Is a JPEG decompressed every time you view it on a computer?} Yes

  \item \textit{When LSBR is used on RGB images, which bit(s) are changed?} Good question - it depends, but usually the LSBs of all three components (in sync)

  \end{itemize}

\item After embedding a payload, the original cover is destroyed. Otherwise, two nearly identical images would be floating around and Alice could easily be outed if someone got their hands on both versions.

\end{itemize}


\section{03/10/18}

\begin{itemize}

\item What I did: N/A

\item Discussed software to be used for embedding (J-UNIWARD), feature extraction (JRM), and detection (ensemble of linear classifiers)
  \begin{itemize}
  \item All the software is \href{http://dde.binghamton.edu/download/stego_algorithms/}{here}
  \end{itemize}

\item Server's IP: 163.1.88.150

\item Amounts of payload to embed: $O(1)$, $O(\sqrt{n})$, $O(\sqrt{n} \log n)$, $O(n)$

\item $m \sim \frac{\sqrt{DC}}{2} \log \frac{C}{D}$

\item TIME EVERYTHING

\item I will test new embedding and new detecting methods and I could also try old embedding and new detecting methods

\item Total amount of space needed (assuming around 10,000 images are used):
  \begin{itemize}
  \item Images: $2MB \times 10000 \times 9 \approx 180GB$
  \item Costs: $8B \times 5M \times 10000 \approx 400 GB$
  \item Features: $170KB \times 10000 \times 9 \approx 17GB$
  \end{itemize}

\end{itemize}


%-----------------------
\chapter{Notes to Self}

\section{Useful Commands}

\begin{itemize}

\item Run a command in the background so that you can keep using the terminal or close it
  \begin{itemize}
  \item \texttt{nohup python script.py \&> script\_output.out \&}
  \end{itemize}

\item Check on processes that are running
  \begin{itemize}
  \item \texttt{ps aux | grep vlasov}
  \end{itemize}

\item See what processes are currently running, how many resources they're using, etc.
  \begin{itemize}
  \item \texttt{htop}
  \end{itemize}

\item View information on how much RAM is used, available, etc.
  \begin{itemize}
  \item \texttt{free}
  \end{itemize}

\item Compile MATLAB code
  \begin{itemize}
  \item \texttt{mcc -m [-v] abc\_xyz.m}
  \end{itemize}

\item Run script generated by \texttt{mcc}
  \begin{itemize}
  \item \texttt{./run\_abc\_xyz.sh /usr/local/matlab-r2014a/}
  \end{itemize}

\item Delete all empty files (i.e. size 0) in the current directory:
  \begin{itemize}
  \item \texttt{find . -size 0 -delete}
  \end{itemize}

\end{itemize}


\section{Experiment Pipeline}
\begin{enumerate}
  \item Pre-processing: \texttt{actor3\_preprocessing.py} or \texttt{bossbase\_preprocessing.py}
  \item Cropping: \texttt{crop.py}
  \item Costs: \texttt{compute\_costs.py}, \texttt{J-UNIWARD-COSTS}
  \item Features: \texttt{do\_fea\_partitioned.sh}, \texttt{compute\_features.py}, \texttt{jrm}
  \item Embedding:
    \begin{itemize}
      \item Ternary J-UNIWARD: \texttt{J-UNIWARD-EMBED-WITH-COSTS}
      \item Binary J-UNIWARD: \texttt{BINARY-EMBED}
    \end{itemize}
  \item Feature matrix: \texttt{combine\_feature\_files.py} then \texttt{run\_txt\_to\_mat.sh}
  \item Linear classifier: \texttt{run\_juniward\_test.sh}
\end{enumerate}

\section{Lessons Learned}
\label{sec:lessons-learned}

\begin{itemize}

\item The input and output file to \texttt{jpegtran} can't be the same, otherwise you get an ``\texttt{Empty input file}'' error.

\item If it looks like directories on the server have disappeared, turn off f.lux or change the colour settings in \texttt{.bashrc}.

\item Beware that in Python versions earlier than 2.3, the \texttt{log} function computes the natural logarithm. In version 2.3, an optional \texttt{base} argument was added in order to specify the base of the logarithm. So, if you execute \texttt{log(64,2)} with a Python version earlier than 2.3, the second argument is ignored and you get the natural logarithm of 64.

\item If I use \texttt{at} to schedule tasks, I will not have access to the standard output because it tries to email it to me, which fails because there is no mail transfer agent installed.

\item Back up features (\texttt{.mat} files) to \texttt{/home} because it is backed up whereas \texttt{/array} is not. Nothing happened yet, but just in case. Last backup was 27/02/19.

\end{itemize}


%-----------------------
\chapter{Actor00003 Results}
\label{sec:actor3-results}

\section{Cover Images}
\input{results/actor3_cover}

\newpage
\section{Ternary Embedding (\texorpdfstring{$\alpha=0.1$}{alpha})}
\input{results/actor3_juni_01}

\newpage
\section{Ternary Embedding (other \texorpdfstring{$\alpha$}{alpha} values)}
\input{results/actor3_juni_other}

\newpage
\section{\texorpdfstring{$O(1)$}{O(1)} Binary Embedding}
\input{results/actor3_bin_O(1)}

\newpage
\section{\texorpdfstring{$O(\sqrt{n})$}{O(sqrt(n))} Binary Embedding}
\input{results/actor3_bin_O(sqrt)}

\newpage
\section{\texorpdfstring{$O(\log{n} \cdot \sqrt{n})$}{O(log(n)*sqrt(n))} Binary Embedding}
\input{results/actor3_bin_O(log_sqrt)}

\newpage
\section{\texorpdfstring{$O(n)$}{O(n)} Binary Embedding}
\input{results/actor3_bin_O(n)}


%-----------------------
\chapter{BOSSbase Results}

\section{Cover Images}
\input{results/bossbase_cover}

\newpage
\section{Binary Embedding to Pick Constants}
\input{results/bossbase_bin_test}

\newpage
\section{\texorpdfstring{$O(1)$}{O(1)} Binary Embedding}
\input{results/bossbase_bin_O(1)}

\newpage
\section{\texorpdfstring{$O(\sqrt{n})$}{O(sqrt(n))} Binary Embedding}
\input{results/bossbase_bin_O(sqrt)}

\newpage
\section{\texorpdfstring{$O(\log{n} \cdot \sqrt{n})$}{O(log(n)*sqrt(n))} Binary Embedding}
\input{results/bossbase_bin_O(log_sqrt)}

\newpage
\section{\texorpdfstring{$O(n)$}{O(n)} Binary Embedding}
\input{results/bossbase_bin_O(n)}

\end{document}